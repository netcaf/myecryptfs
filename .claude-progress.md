# eCryptfs Custom ACL — Project Progress

**Date**: 2026-02-15
**Kernel**: Linux 5.15.196-custom (out-of-tree module at `/home/pi/ecryptfs/`)
**Branch**: `main` (clean, commits: `b38995f`, `a2be7b3`)
**Status**: Design/planning phase — no code written yet

---

## 1. Goal

Add a custom ACL mechanism to eCryptfs that:
- Runs **after** standard POSIX/VFS permissions pass (two-stage model)
- Matches on **UID, GID, process executable path** (and combinations)
- Controls both **allow/deny** AND **plaintext vs ciphertext** data delivery per-process
- Persists across reboots via xattr on the lower filesystem
- Requires kernel enforcement + userspace management tool

---

## 2. Codebase Analysis (Completed)

### Current State — No ACL Support
- `ecryptfs_permission()` at `inode.c:872-878` is a simple passthrough to `inode_permission(lower_inode)`
- `SB_POSIXACL` flag inherited from lower fs at `main.c:561-562`
- All xattr ops delegate to lower fs via catch-all handler (`prefix=""`) at `inode.c:1186-1195`
- No `set_acl`/`get_acl` callbacks in any `inode_operations` struct

### Key Code Locations Identified
| Location | Purpose |
|----------|---------|
| `inode.c:872-878` | `ecryptfs_permission()` — permission hook (Point 1) |
| `file.c:191-240` | `ecryptfs_open()` — file open, metadata loading (Point 2) |
| `file.c:32-45` | `ecryptfs_read_update_atime()` — read entry point (Point 3) |
| `mmap.c:191-221` | `ecryptfs_readpage()` — decrypt/cipher branch (`VIEW_AS_ENCRYPTED` flag) |
| `mmap.c:538-555` | `ecryptfs_aops` — address space operations |
| `super.c` | `ecryptfs_alloc_inode()` / `ecryptfs_evict_inode()` — inode lifecycle |
| `ecryptfs_kernel.h:252-259` | `ecryptfs_inode_info` — per-inode private data |
| `ecryptfs_kernel.h:355-358` | `ecryptfs_file_info` — per-fd private data |
| `main.c:476-617` | `ecryptfs_mount()` — mount setup |

### Kernel APIs Verified (5.15.196 signatures)
- `inode_permission(struct user_namespace *, struct inode *, int)`
- `get_task_exe_file(struct task_struct *)` → `struct file *` (RCU-safe, no mmap_lock needed)
- `d_path(const struct path *, char *, int)` → `char *`
- `vfs_iter_read(struct file *, struct iov_iter *, loff_t *, rwf_t)`
- `__vfs_getxattr(dentry, inode, name, value, size)`
- `__vfs_setxattr_locked(user_ns, dentry, name, value, size, flags, NULL)`
- `current_uid()`, `current_gid()`, `from_kuid()`, `from_kgid()`

---

## 3. Architecture Decisions (Completed)

### Three-Point Enforcement Model

We determined through analysis that a single enforcement point is **insufficient** because:
1. `ecryptfs_permission()` can only return allow/deny (0 or -EACCES) — cannot control what data is served
2. The page cache is per-inode (shared) — cannot serve plaintext to one process and ciphertext to another from the same cache
3. Cipher-mode readers must bypass the eCryptfs page cache entirely and read from the lower file

```
Process opens file
    │
    ▼
POINT 1: ecryptfs_permission()          [inode.c:872]
  Stage 1: inode_permission(lower)      → standard POSIX check
  Stage 2: ecryptfs_acl_check_access()  → custom ACL identity gate
  Result: DENY → -EACCES, ALLOW → proceed
  Handles: MAY_NOT_BLOCK (RCU walk) → -ECHILD if cache cold
    │
    ▼
POINT 2: ecryptfs_open()               [file.c:191, after line 235]
  Query ACL again → determine PLAINTEXT or CIPHERTEXT mode
  Store in per-fd: file_info->acl_access_mode
  Why per-fd: different processes may get different modes for same inode
    │
    ▼
POINT 3: ecryptfs_read_update_atime()  [file.c:32]
  Branch on file_info->acl_access_mode:
    CIPHER → vfs_iter_read(lower_file) — bypass page cache, raw ciphertext
    PLAIN  → generic_file_read_iter()  — page cache + decrypt, plaintext
```

### Storage: xattr `security.ecryptfs_acl`
- Binary format: header (8B) + variable-length entries
- Each entry: uid(4B) + gid(4B) + action(1B) + perms(1B) + path_len(2B) + path(variable)
- ~35-60 entries per file on ext4 (4KB xattr limit)
- Cached in `ecryptfs_inode_info.custom_acl` (per-inode, lazy-loaded)

### Evaluation Semantics: Deny-Wins
1. No ACL entries → allow all, plaintext (backward compatible)
2. Any matching DENY → -EACCES
3. Any matching ALLOW → allow, mode from entry's perms (rp=plaintext, rc=ciphertext)
4. No entries match → allow

### Permission Bits (eCryptfs-specific)
- `PERM_READ_PLAIN  0x01` — read decrypted content
- `PERM_READ_CIPHER 0x02` — read raw encrypted content
- `PERM_WRITE       0x04` — write
- `PERM_EXEC        0x08` — execute

---

## 4. Implementation Plan (Written, Pending Approval)

**Full plan file**: `/home/pi/.claude/plans/zazzy-wishing-lerdorf.md`

### Files to Create
| File | Purpose |
|------|---------|
| `acl.c` | Core ACL logic: init/free/load/save/check/match/get_mode, exe path resolution |
| `tools/ecryptfs_acl.c` | Userspace CLI tool for managing ACL rules |

### Files to Modify
| File | Changes |
|------|---------|
| `ecryptfs_kernel.h` | Add ACL structs, defines, `acl_access_mode` field in `ecryptfs_file_info`, `custom_acl` field in `ecryptfs_inode_info` |
| `inode.c` | Expand `ecryptfs_permission()` with Stage 2 check; cache invalidation in `ecryptfs_xattr_set()` |
| `file.c` | `ecryptfs_open()` stores plain/cipher mode; `ecryptfs_read_update_atime()` branches on mode |
| `super.c` | Init ACL in `alloc_inode()`, free in `evict_inode()` |
| `Makefile` | Add `acl.o` to `ecryptfs-y` |

### Functions to Implement in `acl.c`
1. `ecryptfs_acl_init()` — initialize per-inode ACL cache
2. `ecryptfs_acl_free()` — cleanup per-inode ACL cache
3. `ecryptfs_acl_load()` — read xattr, parse binary to in-memory list
4. `ecryptfs_acl_save()` — serialize in-memory list, write xattr
5. `ecryptfs_get_current_exe_path()` — resolve current process exe via `get_task_exe_file()` + `d_path()`
6. `ecryptfs_acl_match_entry()` — match uid/gid/exe_path against one ACL entry
7. `ecryptfs_acl_check_access()` — Point 1: deny-wins evaluation for allow/deny
8. `ecryptfs_acl_get_file_mode()` — Point 2: extract plaintext/ciphertext mode from ACL

### Userspace Tool Commands
```
ecryptfs_acl add <file> --uid=<N|*> --gid=<N|*> --proc=<path|*> --perm=<rp|rc|w|x,...> --action=<allow|deny>
ecryptfs_acl list <file>
ecryptfs_acl remove <file> --index=<N>
ecryptfs_acl clear <file>
```

---

## 5. Open Items / Not Yet Decided

- **Cipher-mode write**: Dangerous (can corrupt encrypted file structure). Plan notes to make cipher mode read-only initially.
- **Write path branching**: Similar to read path, needs `generic_file_write_iter()` vs `vfs_iter_write(lower_file)` branching. Deferred until cipher-write decision is made.
- **mmap path**: Not yet addressed. Processes that mmap the file may need special handling since mmap goes through page cache directly.
- **Concurrent plain+cipher readers**: Need to verify no page cache coherency issues when one process reads via page cache (plain) and another bypasses it (cipher) simultaneously.

---

## 6. Related Files

| File | Purpose |
|------|---------|
| `/home/pi/.claude/plans/zazzy-wishing-lerdorf.md` | Full implementation plan |
| `/home/pi/.claude/projects/-home-pi-ecryptfs/memory/MEMORY.md` | Persistent memory for Claude sessions |
| `/home/pi/.claude/projects/-home-pi-ecryptfs/memory/acl-design.md` | Detailed design notes |
